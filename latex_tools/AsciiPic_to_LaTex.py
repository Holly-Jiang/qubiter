{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fswiss\fcharset0 Arial;}}
{\*\generator Msftedit 5.41.15.1515;}\viewkind4\uc1\pard\f0\fs20 import numpy as np\par
import copy as cp\par
from Controls import *\par
\par
\par
class AsciiPic_to_LaTex:\par
    """\par
    This class can translate a Qubiter Picture file (which is a text file\par
    that contains an ASCII picture of a quantum circuit) into LaTex code\par
    that can be compiled into a scholarly, publication quality eps or pdf\par
    picture of the circuit. The LaTex code generated by this class calls\par
    commands from the package QCircuit, which in turn calls commands from\par
    the package xypic.\par
    References\par
    ----------\par
    1. Bryan Eastin, S. Flammia, "Q-circuit Tutorial",\par
    https://arxiv.org/abs/quant-ph/0406003v2\par
    2. K.H. Rose, "xypic users's guide"\par
    (There is also a much longer "xypic reference manual"\par
    You can use the LaTex code produced by this class as a starting point.\par
    You can tweak the code by hand by adding annotations in LaTex or by\par
    changing various parameters as explained in the xypic and Qcircuit\par
    documentation.\par
    Instead of going from Qubiter Picture file to Latex code directly,\par
    this class inserts an intermediate translation step that we call a Tiny\par
    ascii picture. A Tiny picture is a simplified, abridged version of a\par
    Qubiter "native" Picture file. In Qubiter native pictures, each gate is\par
    made up of multiple bonds, and each bond is 4 characters long. A Tiny\par
    picture uses 1 character per bond instead of 4, usually retaining only\par
    the first character of each bond of the counterpart Qubiter native\par
    picture. Hence, a Tiny picture is exactly 1/4 as long as its Qubiter\par
    native picture counterpart. Qubiter native pictures and Tiny pictures\par
    can both be machine generated by Qubiter or written by hand. Because\par
    they are 1/4 as long, Tiny pictures are easier to write by hand than\par
    Qubiter native pictures.\par
    Here is a quantum circuit with 7 qubits and 9 gates expressed in Qubiter\par
    native picture format and in Tiny picture format. In both pictures,\par
    time points downwards. Each line (row) represents one gate, or one unit\par
    of time. Columns 0, 4, 8, ... represent a qubit in the Qubiter native pic.\par
    Qubiter native pic:\par
    |   X---+---+---@   |   |\par
    |   Y---+---O---@---O   |\par
    |   H   |   |   |   |   |\par
    |   <---+---+--->   |   |\par
    M   |   |   |   |   |   |\par
    @---X   |   |   |   |   |\par
    @---+---+---+---+---X   |\par
    @---+---+---O---+---X   |\par
    Tiny pic:\par
    |X++@||\par
    |Y+O@O|\par
    |H|||||\par
    |<++>||\par
    M||||||\par
    @X|||||\par
    @++++X|\par
    @++O+X|\par
    As you can see, in the Tiny pic, the white spaces and hyphens are\par
    omitted. The following symbols are kept:\par
    kept = [\par
        'H',  # Hadamard matrix\par
        'M',  # measurement of type 2\par
        'O',  # Control of type False\par
        '@',  # Control of type True\par
        'X',  # sigma_X Pauli matrix\par
        'Y',  # sigma_Y Pauli matrix\par
        'Z',  # sigma_Z Pauli matrix\par
        '<',  # left edge of swap gate\par
        '>',  # right edge of swap gate\par
        '|',  # wire connecting two times\par
        '+',  # '|' connecting 2 times crossed by a '-' connecting two qubits\par
        '$']  # place holder to be replaced in LaTex by initial ket of a qubit\par
    In translating a Tiny picture to LaTex, this class will try to interpret\par
    each character of a Tiny pic by using the "kept" list above. If you\par
    insert a character that it can't interpret, like for example an 'A',\par
    it will translate that character to a LaTex one qubit box with an 'A'\par
    inside it.\par
    In Qubiter native pics and Tiny pics, time points down, the way we\par
    normally read  English. In the LaTex pictures generated by this class,\par
    you can choose for time to point either from left to right (>) or vice\par
    versa (<). The > convention is more popular than the < convention,\par
    but the < convention is preferred by the cognescenti because it\par
    recognizes that quantum circuit diagrams are merely a graphical\par
    representation of Dirac notation, and Dirac notation uses the <\par
    convention. Reversing a convention espoused by the universally popular\par
    Dirac notation is a totally needless complication.\par
    Attributes\par
    ----------\par
    gb_char_arr : np.ndarray\par
        This internal variable is a rectangular array of single characters,\par
        of shape (num_gates, num_bits), hence its name starts with gb. Each\par
        gate is a unit of time, and, as usual in Qubiter, the words bit and\par
        qubit are used interchangeably. To build this array, we start by\par
        splitting a Tiny picture into a character array, then we make some\par
        modifications like adding a row of '$' characters and another of '|'\par
        characters as placeholders.\par
    gb_ch_is_measured : np.ndarray[bool]\par
        Internal variable, a bool array of the same shape as gb_char_arr.\par
        For each ch (aka character, node, vertex) entry in gb_char_arr,\par
        the corresponding bool entry of this array answers the question of\par
        whether or not that node is already measured (i.e., whether it\par
        occurs at the same qubit as an M node but after it).\par
    init_states : list[str]\par
        A list of num_bits many strings. Each string will be inserted inside\par
        a ket and displayed in the LaTex picture as the starting state of a\par
        qubit. The strings in the list are ordered in top qubit to bottom\par
        qubit order.\par
    reverse_bits : bool\par
        Set to True iff you want qubit order in Tiny pic to be reversed in\par
        LaTex pic.\par
    reverse_gates : bool\par
        Set to True iff you want gate order in Tiny pic to be reversed in\par
        LaTex pic.\par
    time_dir : str\par
        time_dir = '<' if reverse_gates else '>'\par
    """\par
    def __init__(self, reverse_bits=True, reverse_gates=True):\par
        """\par
        Constructor\par
        Parameters\par
        ----------\par
        reverse_bits : bool\par
        reverse_gates : bool\par
        Returns\par
        -------\par
        None\par
        """\par
        \par
        self.reverse_bits = reverse_bits\par
        self.reverse_gates = reverse_gates\par
        self.time_dir = '<' if self.reverse_gates else '>'\par
        self.last_bit_on_top = self.reverse_bits\par
        \par
        # these change with each tiny_word_list considered\par
        self.init_states = None\par
        self.gb_char_arr = None\par
        self.gb_ch_is_measured = None\par
\par
    @staticmethod\par
    def qubiter_pic_file_to_tiny_word_list(file_path, num_bits, ZL):\par
        """\par
        Reads Qubiter native pic file and returns a tiny word list, which is\par
        a list of words all of which have the same number (=num_bits) of\par
        characters.\par
        Parameters\par
        ----------\par
        file_path : str\par
            Path to Qubiter native pic file.\par
        num_bits : int\par
            Number of qubits. The name of every native pic file generated by\par
            Qubiter states the value of num_bits.\par
        ZL : bool\par
            Set to True iff file is using Zero bit Last convention. Opposite\par
            of ZL is ZF (Zero First). The  name of every native pic file\par
            generated by Qubiter states either ZL or ZF.\par
        Returns\par
        -------\par
        list[str]\par
        """\par
\par
        tiny_word_list = []\par
        inside_if_m_block = False\par
        pic_file_in = open(file_path)\par
        while not pic_file_in.closed:\par
            line = pic_file_in.readline()\par
            if not line:\par
                pic_file_in.close()\par
                break\par
            line = line.replace('-', ' ')\par
            split_line = line.split()\par
            ch_list = []\par
            # print("..", split_line)\par
            if not inside_if_m_block:\par
                m_block_controls = Controls(num_bits)\par
            for vtx in split_line:\par
                # print('vtx', vtx)\par
                if len(vtx) < 3:\par
                    if vtx in ['@', '<', '>', '|', ':', '%', '+',\par
                               'H', 'M', 'O',\par
                               'Rx', 'Ry', 'Rz', 'R', 'X', 'Y', 'Z']:\par
                        ch_list.append(vtx[0])\par
                    elif vtx in ['OP', '@P', 'Ph']:\par
                        ch_list.append('?')\par
                    elif vtx in ['M1', 'M2']:\par
                        assert False, "unsupported measurement type"\par
                    else:\par
                        # print("--", split_line)\par
                        assert False, "unexpected circuit node: '" + vtx + "'"\par
                else:\par
                    ch4 = vtx[0:4]\par
                    if ch4 in ['LOOP', 'NEXT']:\par
                        assert False, "loops not supported by Tiny"\par
                    elif ch4 in ['NOTA', 'PRIN']:\par
                        break\par
                    elif ch4 == 'IF_M':\par
                        inside_if_m_block = True\par
                        # m_block_controls should be empty at this point\par
                        assert not m_block_controls.bit_pos_to_kind\par
                        trols = split_line[1:-1]\par
                        # print('trols', trols)\par
                        trol_bits = [int(x[:-1]) for x in trols]\par
                        trol_kinds = \\\par
                            [True if x[-1] == 'T' else False for x in trols]\par
                        for bit, kind in zip(trol_bits, trol_kinds):\par
                            m_block_controls.bit_pos_to_kind[bit] = kind\par
                        m_block_controls.refresh_lists()\par
                        break\par
                    elif ch4 == '\}IF_':\par
                        inside_if_m_block = False\par
                        break\par
                    else:\par
                        assert False, "unexpected circuit node: '" + vtx + "'"\par
            # print("split_line", split_line)\par
            # ch_list may be empty in cases where broke out of vtx loop\par
            if ch_list:\par
                # give controls of if_m block to gates inside block\par
                assert len(ch_list) == num_bits, str(ch_list)\par
                if inside_if_m_block:\par
                    for bit, kind in m_block_controls.bit_pos_to_kind.items():\par
                        if not ZL:\par
                            ch_list[bit] = '@' if kind else 'O'\par
                        else:\par
                            ch_list[num_bits - bit - 1] = '@' if kind else 'O'\par
                # replace : by |\par
                ch_list = [ch if ch != ':' else '|' for ch in ch_list]\par
\par
                # replace | by + when justified\par
                gate_has_controls_or_swap = False\par
                for ch in ch_list:\par
                    if ch in ['@', 'O', '<', '>']:\par
                        gate_has_controls_or_swap = True\par
                        break\par
                non_vertical_pos = [k for k in range(num_bits)\par
                                    if ch_list[k] != '|']\par
                if gate_has_controls_or_swap:\par
                    min_non_vert = min(non_vertical_pos)\par
                    max_non_vert = max(non_vertical_pos)\par
                    for k in range(min_non_vert+1, max_non_vert):\par
                        if ch_list[k] == '|':\par
                            ch_list[k] = '+'\par
\par
                tiny_word_list.append(''.join(ch_list))\par
        return tiny_word_list\par
    \par
    def process_tiny_word_list(self, tiny_word_list, init_states):\par
        """\par
        Internal function that uses info in the input tiny_word_list to fill\par
        certain attributes of the class.\par
        Parameters\par
        ----------\par
        tiny_word_list : list[str]\par
        init_states : list[str]\par
        Returns\par
        -------\par
        None\par
        """\par
        \par
        word_list = cp.copy(tiny_word_list)\par
        self.init_states = init_states\par
\par
        num_bits = len(word_list[0])\par
        for word in word_list:\par
            assert len(word) == num_bits\par
\par
        def repeated_ch(ch):\par
            return ''.join([ch]*num_bits)\par
\par
        # extend end\par
        if not self.reverse_gates:\par
            # print(word_list, [repeated_ch('|')] )\par
            word_list = word_list + [repeated_ch('|')]\par
        else:\par
            word_list = [repeated_ch('|')] + word_list\par
\par
        if init_states:\par
            word_list = [repeated_ch('$')] + word_list\par
\par
        num_gates = len(word_list)\par
        char_list = []\par
        for word in word_list:\par
            char_list.extend(list(word))\par
        self.gb_char_arr = np.array(char_list).reshape((num_gates, num_bits))\par
\par
        self.gb_ch_is_measured = np.zeros(\par
                    shape=(num_gates, num_bits), dtype=bool)\par
        for gate in range(num_gates):\par
            for bit in range(num_bits):\par
                if self.gb_char_arr[gate, bit] == 'M':\par
                    for gate1 in range(gate+1, num_gates):\par
                        self.gb_ch_is_measured[gate1, bit] = True\par
\par
        # print('..', self.gb_ch_is_measured)\par
        for gate in range(num_gates):\par
            for bit in range(num_bits):\par
                if self.gb_ch_is_measured[gate, bit]:\par
                    assert self.gb_char_arr[gate, bit] in \\\par
                        ['@', 'O', '|', '+'],\\\par
                        "Only admissible ops on a measured qubit are @,O,|,+"\par
\par
        # print("self.gb_char_arr=\\n", self.gb_char_arr)\par
        \par
    @staticmethod\par
    def get_preface_latex():\par
        """\par
        Returns preface code of LaTex document.\par
        Returns\par
        -------\par
        str\par
        """\par
        preface = "\\\\documentclass[12pt]\{article\}\\n"\par
        preface += "\\\\usepackage\{Qcircuit_v2, Qcircuit_extension\}\\n"\par
        preface += "\\\\begin\{document\}\\n"\par
        preface += "\\n\\n"\par
        return preface\par
\par
    @staticmethod\par
    def get_ending_latex():\par
        """\par
        Returns ending code of LaTex document.\par
        Returns\par
        -------\par
        str\par
        """\par
        return "\\\\end\{document\}"\par
\par
    def get_ckt_latex(self, tiny_word_list, init_states=None):\par
        """\par
        Returns LaTex code for quantum circuit described by the input\par
        tiny_word_list.\par
        Parameters\par
        ----------\par
        tiny_word_list : list[str]\par
        init_states : list[str]\par
        Returns\par
        -------\par
        str\par
        """\par
        \par
        self.process_tiny_word_list(tiny_word_list, init_states)\par
\par
        latex_str = "\\\\begin\{equation\}\\n\\\\begin\{array\}\{c\}\\n"\par
        latex_str += "\\\\Qcircuit @C=2em @R=.4em \{\\n"\par
\par
        num_bits = len(tiny_word_list[0])\par
        num_gates = len(tiny_word_list) + 2\par
\par
        for bit in range(num_bits):\par
            _bit = bit\par
            if self.reverse_bits:\par
                _bit = num_bits - bit - 1\par
            if bit > 0:\par
                latex_str += '\\\\\\\\  % bit ' + str(bit) + '\\n'\par
            else:\par
                latex_str += '% bit ' + str(bit) + '\\n'\par
            for gate_num in range(num_gates):\par
                _gate_num = gate_num\par
                if self.reverse_gates:\par
                    _gate_num = num_gates - _gate_num - 1\par
                gate_char = self.gb_char_arr[_gate_num, _bit]\par
                is_m = self.gb_ch_is_measured[_gate_num, _bit]\par
                if gate_char == 'M':\par
                    if self.reverse_gates:\par
                        latex_str += '&\\\\Rmeter'\par
                    else:\par
                        latex_str += '&\\\\meter'\par
                elif gate_char == 'O':\par
                    latex_str += '&\\\\Cogate' if is_m else '&\\\\ogate'\par
                elif gate_char == 'X':\par
                    latex_str += '&\\\\timesgate'\par
                elif gate_char == '<':\par
                    if self.reverse_bits:\par
                        latex_str += '&\\\\darrowgate'\par
                    else:\par
                        latex_str += '&\\\\uarrowgate'\par
                elif gate_char == '>':\par
                    if self.reverse_bits:\par
                        latex_str += '&\\\\uarrowgate'\par
                    else:\par
                        latex_str += '&\\\\darrowgate'\par
                elif gate_char == '@':\par
                    latex_str += '&\\\\Cdotgate' if is_m else '&\\\\dotgate'\par
                elif gate_char == '|':\par
                    latex_str += '&\\\\cw' if is_m else '&\\\\qw'\par
                elif gate_char == '+':\par
                    latex_str += '&\\\\cw' if is_m else '&\\\\qw'\par
                elif gate_char == '$':\par
                    stick = '\\\\lstick' if not self.reverse_gates else ''\par
                    latex_str += '&' + stick + '\{\\\\ket\{' +\\\par
                                 self.init_states[bit] + '\}\}'\par
                else:\par
                    latex_str += '&\\gate\{' + gate_char + '\}'\par
\par
                # add \\qwx\par
                if self.reverse_bits:\par
                    bit_range = reversed(range(num_bits))\par
                else:\par
                    bit_range = range(num_bits)\par
                gate_ch_list = [self.gb_char_arr[_gate_num, k] for\par
                                k in bit_range]\par
                gate_has_controls_or_swap = False\par
                for ch in gate_ch_list:\par
                    if ch in ['@', 'O', '<', '>']:\par
                        gate_has_controls_or_swap = True\par
                        break\par
                non_vertical_pos = [k for k in range(num_bits)\par
                                    if gate_ch_list[k] != '|']\par
                if gate_has_controls_or_swap:\par
                    min_non_vert = min(non_vertical_pos)\par
                    max_non_vert = max(non_vertical_pos)\par
                    for k in range(min_non_vert, max_non_vert):\par
                        if bit-1 == k:\par
                            latex_str += '\\qwx'\par
\par
                latex_str += '\\t\\t% gate ' + str(gate_num) + '\\n'\par
        latex_str += '\}\\n'\par
        latex_str += '\\\\end\{array\}\\n\\\\end\{equation\}\\n\\n'\par
\par
        return latex_str\par
\par
if __name__ == "__main__":\par
\par
    def write_latex_file(file_out):\par
        latex_str = AsciiPic_to_LaTex.get_preface_latex()\par
        for rev_bits in [False, True]:\par
            last_bit_on_top = rev_bits\par
            for rev_gates in [False, True]:\par
                # print('case', rev_bits, rev_gates)\par
                time_dir = '<' if rev_gates else '>'\par
                latex_str += "\\nlast bit on top=" + str(last_bit_on_top)\par
                latex_str += ", time dir= $" + time_dir + '$\\n\\n'\par
                trans = AsciiPic_to_LaTex(rev_bits, rev_gates)\par
                latex_str += trans.get_ckt_latex(tiny_word_list, init_states)\par
        latex_str += AsciiPic_to_LaTex.get_ending_latex()\par
        with open(file_out, "w") as fi:\par
            fi.write(latex_str)\par
\par
    # test 1 ---------------\par
    print('test 1')\par
    num_bits = 7\par
    file_out = "latex_test1.tex"\par
    tiny_word_list = [\par
        "|X++@||",\par
        "|Y+O@O|",\par
        "HH|||||",\par
        "|<++>||",\par
        "M|M|M||",\par
        "@X|||||",\par
        "@++++X|",\par
        "@++O+X|"]\par
    init_states = [str(bit) for bit in range(num_bits)]\par
    # init_states = None\par
\par
    print(tiny_word_list)\par
    write_latex_file(file_out)\par
\par
    # test 2 ---------------\par
    print("test 2")\par
    num_bits = 7\par
    file_in = "latex_test_pic.txt"\par
    tiny_word_list = AsciiPic_to_LaTex.qubiter_pic_file_to_tiny_word_list(\par
        file_in, num_bits, ZL=True)\par
    print(tiny_word_list)\par
\par
    # test 3 ---------------\par
    print('test 3')\par
    num_bits = 3\par
    file_in = '../io_folder/teleportation-with-ifs_3_ZLpic.txt'\par
    file_out = 'latex_test_telep.tex'\par
    tiny_word_list = AsciiPic_to_LaTex.qubiter_pic_file_to_tiny_word_list(\par
        file_in, num_bits, ZL=True)\par
    print(tiny_word_list)\par
    init_states = ['0']*num_bits\par
    write_latex_file(file_out)\par
\par
}
 